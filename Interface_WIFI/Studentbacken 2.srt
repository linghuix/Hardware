1
00:00:02,250 --> 00:00:08,290
我想记录一下关于使用ESP32

2
00:00:09,150 --> 00:00:12,790
来编辑传输数据到电脑上

3
00:00:12,790 --> 00:00:14,550
通过MatLab接收的

4
00:00:15,210 --> 00:00:19,190
WiFi通讯过程中的一些问题

5
00:00:20,330 --> 00:00:22,190
我发现的第一个问题：

6
00:00:24,190 --> 00:00:26,970
WiFi数据包传过去的时候

7
00:00:27,450 --> 00:00:28,850
因为它内部算法（ TCP 堆积小包 Nagle 算法）

8
00:00:28,850 --> 00:00:32,150
它是会把包整合到一起

9
00:00:32,150 --> 00:00:33,330
然后一起发送

10
00:00:33,330 --> 00:00:36,130
这样提高它的一个通讯速度

11
00:00:36,890 --> 00:00:38,370
或者说通讯效率

12
00:00:40,230 --> 00:00:42,710
这样这会导致

13
00:00:42,710 --> 00:00:44,850
我ESP32比方说

14
00:00:44,850 --> 00:00:47,230
每10毫秒发送一个

15
00:00:48,270 --> 00:00:50,210
传感器的一个数据

16
00:00:50,210 --> 00:00:51,230
Float类型的

17
00:00:51,230 --> 00:00:52,310
它就会

18
00:00:52,310 --> 00:00:55,610
它就不能每10毫秒发送一次

19
00:00:55,610 --> 00:00:57,710
它会把比方说

20
00:00:57,710 --> 00:00:59,010
50毫秒的数据

21
00:00:59,010 --> 00:01:00,790
5个数据一起发过去

22
00:01:01,910 --> 00:01:05,110
这样就会导致我接收的时候

23
00:01:05,110 --> 00:01:09,570
它那个间隔并不是10毫秒而一次的

24
00:01:11,310 --> 00:01:14,210
这就会对那个实时的一个接收

25
00:01:14,210 --> 00:01:15,690
会产生的影响

26
00:01:16,610 --> 00:01:18,810
就现在解决的方法就是

27
00:01:19,770 --> 00:01:21,090
问了一下chatGPT

28
00:01:21,090 --> 00:01:21,850
第一个就是

29
00:01:22,490 --> 00:01:23,830
取消它这种

30
00:01:24,390 --> 00:01:25,630
把多个数据之后

31
00:01:25,630 --> 00:01:28,670
在一起发送的这样一个算法

32
00:01:29,710 --> 00:01:30,870
里面有个函数

33
00:01:30,870 --> 00:01:32,170
叫做什么TCP

34
00:01:32,170 --> 00:01:32,870
No Delay

35
00:01:33,450 --> 00:01:35,990
在那个Arduino IDE里面

36
00:01:36,850 --> 00:01:37,710
但是呢

37
00:01:37,710 --> 00:01:39,030
通过做SOP

38
00:01:39,030 --> 00:01:40,170
还是不能完全

39
00:01:41,210 --> 00:01:42,170
把这个

40
00:01:43,210 --> 00:01:45,970
把这个情况给消除掉

41
00:01:48,230 --> 00:01:49,970
所以我想到另外一个方法

42
00:01:49,970 --> 00:01:51,950
就是在那个数据的前面

43
00:01:52,650 --> 00:01:53,590
在数据上面

44
00:01:53,590 --> 00:01:55,570
加上一个时间戳

45
00:01:57,570 --> 00:01:58,770
因为Adorno里面

46
00:01:58,770 --> 00:02:01,370
ESP32里面是有一个定时器的

47
00:02:01,930 --> 00:02:03,310
只要开启那个定时器

48
00:02:03,830 --> 00:02:05,730
然后把定时器里面的数据

49
00:02:05,730 --> 00:02:08,230
给跟那个传感器读到的数据

50
00:02:08,230 --> 00:02:09,110
同时发出来

51
00:02:10,490 --> 00:02:10,850
这样

52
00:02:11,790 --> 00:02:13,510
在MATLAB电脑上面

53
00:02:13,510 --> 00:02:15,030
就会接收到一个时间戳

54
00:02:15,030 --> 00:02:17,590
加上一个传感器的一个数据值

55
00:02:18,430 --> 00:02:19,810
然后我就可以解析出来

56
00:02:20,770 --> 00:02:21,490
把那个

57
00:02:22,410 --> 00:02:23,710
这个传感器值

58
00:02:23,710 --> 00:02:26,330
采集到采集的时刻

59
00:02:26,910 --> 00:02:28,030
给记录下来

60
00:02:28,030 --> 00:02:29,510
这样我就能知道

61
00:02:30,310 --> 00:02:31,230
这个数据帮

62
00:02:31,610 --> 00:02:32,610
每个间隔

63
00:02:33,070 --> 00:02:34,050
距离是多少

64
00:02:34,950 --> 00:02:36,570
这样我在MATLAB里面

65
00:02:36,570 --> 00:02:38,450
就能够实时的画出来

66
00:02:39,570 --> 00:02:40,470
采集时刻

67
00:02:40,470 --> 00:02:42,110
所对应的一个采集值

68
00:02:44,230 --> 00:02:45,790
就会出现间隔

69
00:02:46,350 --> 00:02:47,650
就是奇奇怪怪的情况

70
00:02:47,650 --> 00:02:48,150
所以我说

71
00:02:49,310 --> 00:02:50,570
我是哈喵的一个

72
00:02:50,570 --> 00:02:51,710
采集频率

73
00:02:51,710 --> 00:02:53,310
在它实际在MATLAB里面

74
00:02:53,310 --> 00:02:53,990
介绍到的是

75
00:02:53,990 --> 00:02:54,810
我说

76
00:02:54,810 --> 00:02:56,230
踩到第一个数据点

77
00:02:56,230 --> 00:02:57,290
然后过50毫秒

78
00:02:57,290 --> 00:02:58,430
再踩到第二个数据点

79
00:02:58,430 --> 00:03:00,470
然后再过0.1毫秒

80
00:03:01,430 --> 00:03:02,150
第三个

81
00:03:02,150 --> 00:03:03,530
0.1毫秒第四个

82
00:03:03,530 --> 00:03:05,330
然后又是50毫秒

83
00:03:06,290 --> 00:03:07,050
第五个

84
00:03:08,290 --> 00:03:08,650
对

85
00:03:10,990 --> 00:03:12,630
但是这个方法的话

86
00:03:14,150 --> 00:03:16,590
对于那个实时的一个控制

87
00:03:16,590 --> 00:03:18,050
可能会有一个情况

88
00:03:18,050 --> 00:03:19,110
会有影响

89
00:03:22,070 --> 00:03:23,110
比方说

90
00:03:25,050 --> 00:03:25,890
因为它

91
00:03:25,890 --> 00:03:27,690
我采集到的数据

92
00:03:27,690 --> 00:03:29,830
在电脑里面解释之后

93
00:03:30,710 --> 00:03:31,810
它并不是

94
00:03:33,110 --> 00:03:34,030
它只是

95
00:03:34,810 --> 00:03:36,110
就是你采集到数据

96
00:03:36,110 --> 00:03:39,270
和它对应采集数据时刻的一个时间

97
00:03:39,270 --> 00:03:40,990
而并不一定是我

98
00:03:41,510 --> 00:03:44,630
MATLAB在笔记本上接收到的一个时间

99
00:03:48,030 --> 00:03:51,650
所以就会出现一定的一个延迟

100
00:03:52,430 --> 00:03:57,610
因为我接收时间肯定是比它采集的那个时间要晚一点的

101
00:04:00,610 --> 00:04:04,190
这样的话就会对我实时控制会采集一定的影响

102
00:04:07,360 --> 00:04:08,700
因为链纳上来说

103
00:04:08,700 --> 00:04:10,840
我在采集那个

104
00:04:11,660 --> 00:04:12,460
出去的时候

105
00:04:12,460 --> 00:04:15,420
我就应该实时的已经发出对应的一个指令了

106
00:04:15,420 --> 00:04:16,860
但是因为延迟

107
00:04:16,860 --> 00:04:19,180
我接收到实际这个采量值的时候

108
00:04:19,180 --> 00:04:20,420
可能已经是

109
00:04:21,160 --> 00:04:22,540
20毫秒之后了

110
00:04:22,540 --> 00:04:25,240
所以对实时控制会有一定影响

111
00:04:25,800 --> 00:04:27,060
但是这个影响的话

112
00:04:27,060 --> 00:04:28,540
我可以通过

113
00:04:30,200 --> 00:04:31,700
在MATLAB里面

114
00:04:31,700 --> 00:04:33,720
把这个实际的一个

115
00:04:35,460 --> 00:04:37,900
我通过MATLAB是可以计算出来的

116
00:04:37,900 --> 00:04:39,180
我接收到的时间

117
00:04:39,180 --> 00:04:41,980
和它采样的那个时间的一个差值

118
00:04:43,540 --> 00:04:44,500
距离是多少

119
00:04:45,200 --> 00:04:47,140
然后我大概做了一下时间

120
00:04:48,080 --> 00:04:48,920
就是我

121
00:04:49,500 --> 00:04:50,600
我用那个encoder

122
00:04:51,340 --> 00:04:52,560
在那个HIP X

123
00:04:52,560 --> 00:04:56,080
HIP那个宽关节的外骨格的那个

124
00:04:56,600 --> 00:04:58,440
encoder的一个采样数据

125
00:04:59,640 --> 00:05:01,720
和我们MATLAB上面接收的一个

126
00:05:01,720 --> 00:05:02,600
那个延迟

127
00:05:02,600 --> 00:05:03,740
我算了一下

128
00:05:03,740 --> 00:05:04,560
大概是

129
00:05:05,520 --> 00:05:09,260
比如是在0.06秒以内的

130
00:05:09,960 --> 00:05:11,180
这个指动啊

131
00:05:11,180 --> 00:05:13,260
我感觉用来实时控制

132
00:05:13,260 --> 00:05:14,040
我的那个

133
00:05:14,640 --> 00:05:16,440
宽关节外骨格的一个

134
00:05:18,700 --> 00:05:19,100
呃

135
00:05:19,100 --> 00:05:21,080
助力值应该是够的

136
00:05:22,620 --> 00:05:23,020
嗯

137
00:05:26,880 --> 00:05:29,540
所以大概的一个WiFi通讯的一个解决方案

138
00:05:29,540 --> 00:05:30,900
大概就是这两个

139
00:05:30,900 --> 00:05:32,520
一个是设置

140
00:05:32,520 --> 00:05:33,060
node delay

141
00:05:33,800 --> 00:05:36,420
在那个advnode单变机里面的代码上面

142
00:05:36,420 --> 00:05:37,280
另外一个就是

143
00:05:37,800 --> 00:05:38,200
啊

144
00:05:38,200 --> 00:05:39,540
在放数据的时候

145
00:05:39,540 --> 00:05:40,820
再添加一个时间戳

146
00:05:41,820 --> 00:05:42,220
啊

147
00:05:43,100 --> 00:05:44,840
然后再详细记录一下

148
00:05:45,740 --> 00:05:47,040
我在那个电脑上

149
00:05:47,040 --> 00:05:49,200
MATLAB代码是如何解析这个

150
00:05:49,960 --> 00:05:50,360
啊

151
00:05:51,000 --> 00:05:51,800
时间戳的

152
00:05:53,600 --> 00:05:54,040
啊

153
00:05:54,040 --> 00:05:54,840
因为那个

154
00:05:56,320 --> 00:06:00,840
这个时间戳是基于那个单变机里面的一个定时器的

155
00:06:01,720 --> 00:06:05,800
跟我实际的电脑上面的一个时间是不同步的

156
00:06:06,260 --> 00:06:08,280
比如说我发过来一个数据包

157
00:06:08,280 --> 00:06:10,380
它时间戳是一万毫秒

158
00:06:11,760 --> 00:06:14,440
但我不知道它对应的一个实际

159
00:06:14,440 --> 00:06:16,660
对应的一个实际的一个时间是多少

160
00:06:17,160 --> 00:06:19,400
跟我们MATLAB上面的一个时间是

161
00:06:20,340 --> 00:06:21,460
完全不笔配的

162
00:06:21,460 --> 00:06:23,040
所以我就通过

163
00:06:24,020 --> 00:06:26,040
我把第一个数据包

164
00:06:26,540 --> 00:06:27,640
上面的时间戳

165
00:06:29,160 --> 00:06:33,440
和我接收到第一个数据包的一个

166
00:06:33,440 --> 00:06:34,880
电脑上的一个时间

167
00:06:35,620 --> 00:06:37,040
我把它记录下来

168
00:06:38,200 --> 00:06:39,860
然后把它当作是

169
00:06:40,520 --> 00:06:41,000
把

170
00:06:41,000 --> 00:06:43,240
我把它当作这两个时间

171
00:06:44,120 --> 00:06:45,440
是同时发生的

172
00:06:45,440 --> 00:06:46,860
所以我记录

173
00:06:48,600 --> 00:06:50,440
第一个数据包的一个

174
00:06:50,440 --> 00:06:53,460
在单变机和在电脑上的一个时间差

175
00:06:54,040 --> 00:06:54,940
把它记录下来

176
00:06:54,940 --> 00:06:57,600
然后我在接收之后的一个数据包的时候

177
00:06:58,380 --> 00:07:00,300
我就通过这个去通过

178
00:07:00,300 --> 00:07:02,820
单变机的时间和MATLAB的时间

179
00:07:04,200 --> 00:07:04,640
然后

180
00:07:06,660 --> 00:07:07,800
对就是这样

181
00:07:09,120 --> 00:07:10,500
这样我就通过了

182
00:07:11,040 --> 00:07:12,880
实现一个数据包的一个接收

183
00:07:12,880 --> 00:07:13,820
确保

184
00:07:14,860 --> 00:07:17,920
单变机时间和我电脑上的时间是完全一样的

185
00:07:43,590 --> 00:07:44,130
但是呢

186
00:07:44,130 --> 00:07:46,030
这里需要明确的是

187
00:07:46,030 --> 00:07:48,370
只是在接收第一个数据包的时候

188
00:07:49,050 --> 00:07:51,050
电脑上的时间和单变机时间

189
00:07:53,970 --> 00:07:56,890
在接收和发送的时候是同步的

190
00:07:56,890 --> 00:07:58,250
之后可能是因为

191
00:07:58,250 --> 00:08:00,230
因为有延迟的情况

192
00:08:01,210 --> 00:08:03,870
我电脑上在接收这个数据包的时候

193
00:08:03,870 --> 00:08:05,690
肯定是比它采集的时候要

194
00:08:06,290 --> 00:08:08,730
要那个更加延后的

195
00:08:10,350 --> 00:08:11,910
这是一个重要点

196
00:08:11,910 --> 00:08:14,350
然后我通过这个时间差

197
00:08:14,970 --> 00:08:16,290
可以计算我的那个

198
00:08:19,310 --> 00:08:21,190
就是传送过程中的一个延迟

199
00:08:22,550 --> 00:08:23,630
我之前也说了

200
00:08:23,630 --> 00:08:26,670
大概就是0.06秒的样子

201
00:08:26,670 --> 00:08:28,870
应该是可以实际的使用的

